# 库存扣减机制分析报告

## 📊 当前项目状态

### 1. 库存字段设计
- ✅ **已实现**：`sessions` 表中有 `stock`（剩余库存）和 `total_stock`（总库存）字段
- ✅ **已实现**：`Sessions` 实体类包含库存字段
- ✅ **已实现**：管理端可以查询库存统计

### 2. 库存扣减逻辑
- ❌ **未实现**：目前项目中**没有实际的库存扣减代码**
- 📝 **文档说明**：数据库初始化脚本中提到"下单时会扣减"，但实际代码中还未实现

### 3. 并发控制机制
- ❌ **未实现乐观锁**：`Sessions` 实体类中**没有 `version` 字段**
- ❌ **未实现分布式锁**：`RedisUtil` 工具类中**没有分布式锁相关方法**
- ⚠️ **风险**：在高并发场景下，可能出现超卖问题

---

## 🔍 问题分析

### 当前存在的问题

1. **缺少库存扣减逻辑**
   - 用户下单时没有扣减库存
   - 订单支付成功后没有扣减库存
   - 订单取消时没有回退库存

2. **缺少并发控制**
   - 没有乐观锁，无法防止并发更新冲突
   - 没有分布式锁，无法防止分布式环境下的并发问题
   - 可能出现超卖：多个用户同时购买同一场次，导致库存扣减错误

3. **缺少库存校验**
   - 下单前没有检查库存是否充足
   - 没有处理库存不足的情况

---

## 💡 解决方案

### 方案一：乐观锁 + 分布式锁（推荐）

**适用场景**：高并发、分布式环境

**实现要点**：
1. **乐观锁**：在 `sessions` 表添加 `version` 字段，使用 `WHERE stock >= ? AND version = ?` 条件更新
2. **分布式锁**：使用 Redis 分布式锁，确保同一场次同一时刻只有一个请求在处理
3. **双重校验**：先查库存，再上锁，再校验，再扣减

**优点**：
- 性能好（乐观锁无阻塞）
- 防止超卖（分布式锁保证原子性）
- 适合高并发场景

**缺点**：
- 实现复杂度较高
- 需要处理锁超时、锁续期等问题

---

### 方案二：仅乐观锁

**适用场景**：单机或低并发场景

**实现要点**：
1. 在 `sessions` 表添加 `version` 字段
2. 使用 `UPDATE sessions SET stock = stock - ?, version = version + 1 WHERE id = ? AND stock >= ? AND version = ?`

**优点**：
- 实现简单
- 性能较好

**缺点**：
- 在分布式环境下可能仍有并发问题
- 需要处理更新失败重试逻辑

---

### 方案三：仅分布式锁

**适用场景**：对性能要求不高的场景

**实现要点**：
1. 使用 Redis 分布式锁
2. 在锁内执行库存扣减

**优点**：
- 实现相对简单
- 保证原子性

**缺点**：
- 性能较差（锁会阻塞）
- 需要处理死锁、锁超时等问题

---

## 🎯 推荐实现方案

**建议采用：乐观锁 + 分布式锁组合方案**

### 实现步骤

1. **数据库层面**
   - 给 `sessions` 表添加 `version` 字段（乐观锁版本号）
   - 添加索引优化查询性能

2. **实体类层面**
   - 在 `Sessions` 实体类添加 `version` 字段

3. **工具类层面**
   - 在 `RedisUtil` 中添加分布式锁方法（基于 Redis SETNX + EXPIRE）

4. **业务逻辑层面**
   - 实现库存扣减服务方法
   - 使用分布式锁 + 乐观锁双重保障
   - 处理库存不足、更新失败等异常情况

5. **订单流程集成**
   - 下单时：预扣库存（可选，使用分布式锁）
   - 支付成功：确认扣减库存（必须）
   - 订单取消/超时：回退库存（必须）

---

## 📝 后续实现建议

1. **立即实现**：乐观锁 + 分布式锁的库存扣减逻辑
2. **测试验证**：编写并发测试用例，验证不会超卖
3. **监控告警**：添加库存扣减失败的监控和告警
4. **性能优化**：根据实际并发量调整锁的超时时间、重试策略

---

## ⚠️ 注意事项

1. **分布式锁超时时间**：需要根据业务处理时间合理设置，避免锁过早释放
2. **乐观锁重试机制**：更新失败时需要重试，但需要限制重试次数
3. **库存回退**：订单取消、支付超时等情况需要及时回退库存
4. **数据一致性**：确保库存扣减和订单创建在同一事务中，保证数据一致性















